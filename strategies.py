import datetime as dt
import math
import telethon
import time
from threading import Thread
from typing import Optional, Union, Dict

from threaded import ThreadedAvellanedaStoikov
from utils import *

import binance

'''
class AvellanedaStoikov:
    def __init__(self, key: str, secret: str, symbols: Union[list, str], risk_factor: float,
                 session_end: int = 23, session_length: int = 14, base_asset: str = 'USDT'):
        """
        :param key: The API key.
        :param secret: The API secret.
        :param symbols: A single symbol name or a list of symbol names to trade. Other than strings containing a symbol
            name, the following special
            strings are allowed:
            - "topX", where X is an integer. In this case, the X most capitalized cryptocurrencies will be selected,
                paired with *base_asset*.
            Case insensitive.
            Examples of valid parameters: "BTCUSDT", ["BTCUSDT", "BNBETH"], "top5", "top20".
        :param risk_factor: Optional, default: 0.1. A risk parameter that ranges from 0.0 to 1.0 (excluded).
        :param session_end: The ending hour of the daily session.
        :param session_length: The length of the daily session in hours.
        :param base_asset: ...
        """
        assert 0.0 < session_length < 24.0, 'Session length out of range'
        assert 0.0 < risk_factor < 1.0, 'Risk factor out of range'

        self.key = key
        self.secret = secret
        self.client = Client(key, secret)
        self.symbols = get_symbols(symbols, base_asset)
        self.base_asset = base_asset
        self.session_end = session_end
        self.session_length = session_length
        self.risk_factor = risk_factor
        self.twm = ThreadedWebsocketManager(self.key, self.secret)

    def start(self):
        self.twm.start()
        for symbol in self.symbols:
            ThreadedAvellanedaStoikov(caller=self, symbol=symbol).start()
        self.twm.join()

    def is_online(self):
        return self.client.ping() == {}

    def get_server_time(self):
        return dt.datetime.fromtimestamp(self.client.get_server_time()['serverTime'] / 1000)
'''

'''
class PerpetualMarketMaking:
    def __init__(self, client: Client, symbols: Union[list, str],
                 bid_spread: Optional[float] = 0.05, ask_spread: Optional[float] = 0.05,
                 tp_spread: Optional[float] = 0.1,
                 base_asset: str = 'USDT'):
        """
        :param client: The API client to use for the strategy.
        :param symbols: A single symbol name or a list of symbol names to trade. Other than strings containing a symbol name, the
            following special
            strings are allowed:
            - "topX", where X is an integer. In this case, the X most capitalized cryptocurrencies will be selected,
                paired with *base_asset*.
            Case insensitive.
            Examples of valid parameters: "BTCUSDT", ["BTCUSDT", "BNBETH"], "top5", "top20".
        :param bid_spread: Optional, default: 0.05. The lower spread (in percentage) from the mid price for the opening buy limit order.
        :param ask_spread: Optional, default: 0.05. The upper spread (in percentage) from the mid price for the opening sell limit order.
        :param tp_spread: Optional, default: 0.10. The percentage spread from the opening price for the take profit order.
                :param base_asset: ...
        """
        self.client = client
        self.symbols = get_symbols(symbols, base_asset)
        self.base_asset = base_asset
        self.bid_spread = bid_spread
        self.ask_spread = ask_spread
        self.tp_spread = tp_spread

    def run(self):
        for symbol in self.symbols:
            thread = Thread(target=self.thread_fn, args=(symbol,))
            thread.start()

    def thread_fn(self, symbol):
        a = self.client.futures_get_open_orders(symbol=symbol)
        print(a)

'''


class PumpAndDump:
    def __init__(self, account: str, base_asset: Optional[str], quote_asset: str, amount: float, is_amount_usd: bool,
                 entry_strategy: str, exit_strategy: str, profit: float, stop_loss: float = 0.0,
                 base_asset_input_mode: str = 'param', trailing_spread: float = 0.0, usd_asset='USDT',
                 # channel_name: str = '', phone_number: str = '',
                 test: bool = False, cred_fp: str = 'cred.json'):
        """
        :param account: (Required) The account used by the strategy. The account must be registered in the credential
            JSON file pointed by <i>cred_fp</i>.
        :type account: str
        :param base_asset: (Optional) The base asset symbol. If it's not given, the strategy asks the user for it at
            runtime. However, <b>note</b> that if <i>base_asset_input_mode</i> == "param", this parameter is required.
        :type base_asset: str
        :param quote_asset: (Required) The quote asset symbol.
        :type quote_asset: str
        :param amount: (Required) The amount of money invested by the strategy. <b>Note:</b> This amount is expressed in
            USD or in quote asset, depending on the parameter <i>is_amount_usd</i>. It is never expressed in base asset.
        :type amount: float
        :param is_amount_usd: (Required) If True, <i>amount</i> is expressed in USD, otherwise in quote asset.
        :type is_amount_usd: bool
        :param entry_strategy: (Required) Can be "fixed", or "span".
        :type entry_strategy: str
        :param exit_strategy: (Required) Can be "fixed", "trailing".
        :type exit_strategy: str
        :param profit: (Required) The desired profit, in %.
        :type profit: float
        :param stop_loss: (Optional) The stop loss from the entry price, in %.
        :type stop_loss: float
        :param base_asset_input_mode (Optional): The following values are allowed.
            "param" (default): the strategy will read the base asset from the parameter <i>base_asset</i>;
            "telegram": the strategy will try to read the base asset symbol from the Telegram channel whose name is
            <i>channel_name</i>;
            "input": the strategy will ask the user to input the base asset symbol.
        :type base_asset_input_mode: str
        :param trailing_spread (Optional): The spread for the trailing stop loss, in %.
            Used only if <i>exit_strategy</i> == "trailing".
        :type trailing_spread: str
        :param usd_asset: The stable asset. Allowed values are "USDT", "USDC", "BUSD", "TUSD", or "USDP".
        :type usd_asset: str
        :param usd_asset: The stable asset. Allowed values are "USDT", "USDC", "BUSD", "TUSD", or "USDP".
        :type usd_asset: str
        :param test (Optional): If True, all the orders are simulated and will never executed. Otherwise, the strategy
            will operate in the real market. Default is False.
        :type test: bool
        """
        self.account = account
        self.base_asset = base_asset
        self.quote_asset = quote_asset
        self.amount = amount
        self.is_amount_usd = is_amount_usd
        self.entry_strategy = entry_strategy
        self.exit_strategy = exit_strategy
        self.profit = profit
        self.stop_loss = stop_loss
        self.base_asset_input_mode = base_asset_input_mode
        self.trailing_spread = trailing_spread
        self.usd_asset = usd_asset
        # self.channel_name = channel_name
        # self.phone_number = phone_number
        self.test = test

        if account not in ['binance', 'binance_sub', 'kucoin']:
            raise ValueError('Account not recognized')
        if not (amount > 0):
            raise ValueError('Amount must be positive')
        if entry_strategy not in ['fixed', 'span']:
            raise ValueError('Entry strategy not recognized')
        if exit_strategy not in ['fixed', 'trailing']:
            raise ValueError('Exit strategy not recognized')
        if not (profit > 0):
            raise ValueError('Profit must be positive')
        if not (0 <= stop_loss <= 100):
            raise ValueError('Stop loss must be in [0, 100] range')
        if base_asset_input_mode not in ['param', 'telegram', 'input']:
            raise ValueError('Base asset input mode not recognized')
        if not (trailing_spread >= 0):
            raise ValueError('Trailing spread must be zero or positive')
        if base_asset_input_mode == 'param' and (type(base_asset) != str):
            raise ValueError("Base asset input mode is 'param', but base asset is not recognized")
        if base_asset_input_mode != 'param' and entry_strategy != 'fixed':
            raise ValueError("Entry strategy must be 'fixed' when the base asset is given at runtime")
        if usd_asset not in ['USDT', 'USDC', 'BUSD', 'TUSD', 'USDP']:
            raise ValueError('Stablecoin not recognized')

        self.client = get_client(account, cred_fp)

    def start(self):
        self.symbol = self.get_symbol()
        self.symbol_info = self.get_symbol_info()
        if not self.quote_asset in ['USDT', 'USDC', 'BUSD', 'TUSD', 'USDP'] and self.is_amount_usd:
            self.usd_info = self.get_usd_info()

        if self.account == 'binance' or self.account == 'binance_sub':
            buy_quote_quantity = self.get_buy_quote_quantity()
            if self.base_asset_input_mode == 'input':
                # BUY
                buy_params = {
                    'symbol': self.symbol,
                    'side': binance.enums.SIDE_BUY,
                    'type': binance.enums.ORDER_TYPE_MARKET,
                    'quoteOrderQty': buy_quote_quantity
                }
                if self.test:
                    buy_order = self.client.create_test_order(**buy_params)
                    avg_buy_price = 0
                else:
                    buy_order = self.client.create_order(**buy_params)
                    avg_buy_price = sum(float(fill['price']) for fill in buy_order['fills']) / len(buy_order['fills'])
                log_order(buy_order, buy_params, avg_buy_price, self.base_asset, self.quote_asset, self.test)
                # SELL
                if not self.test:
                    sell_price = avg_buy_price * (1 + self.profit / 100)
                    sell_params = {
                        'symbol': self.symbol,
                        'side': binance.enums.SIDE_SELL,
                        'type': binance.enums.ORDER_TYPE_LIMIT,
                        'timeInForce': binance.enums.TIME_IN_FORCE_GTC,
                        'quantity': self.format_base_quantity(buy_order['executedQty']),
                        'price': self.format_price(sell_price)
                    }
                    sell_order = self.client.create_order(**sell_params)
                    log_order(sell_order, sell_params, sell_price, self.base_asset, self.quote_asset, self.test)

        elif self.account == 'kucoin':
            raise Exception('Not implemented yet.')

        else:
            raise Exception('account not found.')

    def format_base_quantity(self, qty: Union[float, str]) -> str:
        """
        Format the base asset quantity (returned as a string) for the strategy symbol from a given amount.
        """
        precision = self.symbol_info['baseAssetPrecision']
        return f'{float(qty):.{precision}f}'

    def format_price(self, price: Union[float, str]) -> str:
        """
        Format the price (returned as a string) for the strategy symbol from a given amount.
        """
        precision = self.symbol_info['baseAssetPrecision']
        price_filter = None
        for filter in self.symbol_info['filters']:
            if filter['filterType'] == 'PRICE_FILTER':
                price_filter = filter
                break
        if price_filter:
            print(price_filter)
            tick_size = float(price_filter['tickSize'])
            return f'{(round(float(price) / tick_size) * tick_size):.{precision}f}'
        else:
            return f'{float(price):.{precision}f}'

    def get_buy_quote_quantity(self) -> str:
        """
        Get the quote asset quantity (returned as a string) for the strategy symbol from a given amount. Uses the stable
        asset price for the conversion if necessary. Use Binance quotes even if the strategy uses a different exchange.
        """
        if self.quote_asset in ['USDT', 'USDC', 'BUSD', 'TUSD', 'USDP'] or not self.is_amount_usd:
            precision = self.symbol_info['quoteAssetPrecision']
            return f'{self.amount:.{precision}f}'
        else:
            print(f'Getting {self.quote_asset + self.usd_asset} last price...')
            last_price = float(self.client.get_ticker(symbol=self.quote_asset + self.usd_asset)['lastPrice'])
            precision = self.usd_info['quoteAssetPrecision']
            quote_quantity = self.amount / last_price
            return f'{quote_quantity:.{precision}f}'

    def get_symbol(self) -> str:
        if self.base_asset_input_mode == 'telegram':
            raise Exception('Not implemented yet.')
            # Start a client for sniffing the base asset symbol
            # client = get_telegram_client()

            # @client.on(telethon.events.NewMessage(chats=self.channel_name))
            # async def my_event_handler(event):
            #    print(event.raw_text)

            # client.start(phone=self.phone_number)
            # client.run_until_disconnected()
            # base_asset = None
        elif self.base_asset_input_mode == 'input':
            if self.quote_asset:
                self.base_asset = input("Coin is: ").strip().upper()
            else:
                raise Exception('Quote asset is not given.')

        if self.account == 'binance' or self.account == 'binance_sub':
            return (self.base_asset + self.quote_asset).upper()
        elif self.account == 'kucoin':
            raise Exception('Not implemented yet.')
        else:
            raise Exception('account not found.')

    def get_symbol_info(self) -> dict[str, Any]:
        print(f'Getting {self.symbol} information...')
        info = self.client.get_symbol_info(symbol=self.symbol)
        if info:
            return info
        else:
            raise Exception(f'Symbol {self.symbol} not found on Binance.')

    def get_usd_info(self) -> dict[str, Any]:
        print(f'Getting {self.quote_asset + self.usd_asset} information...')
        info = self.client.get_symbol_info(symbol=self.quote_asset + self.usd_asset)
        if info:
            return info
        else:
            raise Exception(f'Symbol {self.symbol} not found on Binance.')
