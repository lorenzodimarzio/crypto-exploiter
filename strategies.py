import datetime as dt
import math
import telethon
import time
from threading import Thread
from typing import Optional, Union, Dict

from threaded import ThreadedAvellanedaStoikov
from utils import *

import binance

'''
class AvellanedaStoikov:
    def __init__(self, key: str, secret: str, symbols: Union[list, str], risk_factor: float,
                 session_end: int = 23, session_length: int = 14, base_asset: str = 'USDT'):
        """
        :param key: The API key.
        :param secret: The API secret.
        :param symbols: A single symbol name or a list of symbol names to trade. Other than strings containing a symbol
            name, the following special
            strings are allowed:
            - "topX", where X is an integer. In this case, the X most capitalized cryptocurrencies will be selected,
                paired with *base_asset*.
            Case insensitive.
            Examples of valid parameters: "BTCUSDT", ["BTCUSDT", "BNBETH"], "top5", "top20".
        :param risk_factor: Optional, default: 0.1. A risk parameter that ranges from 0.0 to 1.0 (excluded).
        :param session_end: The ending hour of the daily session.
        :param session_length: The length of the daily session in hours.
        :param base_asset: ...
        """
        assert 0.0 < session_length < 24.0, 'Session length out of range'
        assert 0.0 < risk_factor < 1.0, 'Risk factor out of range'

        self.key = key
        self.secret = secret
        self.client = Client(key, secret)
        self.symbols = get_symbols(symbols, base_asset)
        self.base_asset = base_asset
        self.session_end = session_end
        self.session_length = session_length
        self.risk_factor = risk_factor
        self.twm = ThreadedWebsocketManager(self.key, self.secret)

    def start(self):
        self.twm.start()
        for symbol in self.symbols:
            ThreadedAvellanedaStoikov(caller=self, symbol=symbol).start()
        self.twm.join()

    def is_online(self):
        return self.client.ping() == {}

    def get_server_time(self):
        return dt.datetime.fromtimestamp(self.client.get_server_time()['serverTime'] / 1000)
'''

'''
class PerpetualMarketMaking:
    def __init__(self, client: Client, symbols: Union[list, str],
                 bid_spread: Optional[float] = 0.05, ask_spread: Optional[float] = 0.05,
                 tp_spread: Optional[float] = 0.1,
                 base_asset: str = 'USDT'):
        """
        :param client: The API client to use for the strategy.
        :param symbols: A single symbol name or a list of symbol names to trade. Other than strings containing a symbol name, the
            following special
            strings are allowed:
            - "topX", where X is an integer. In this case, the X most capitalized cryptocurrencies will be selected,
                paired with *base_asset*.
            Case insensitive.
            Examples of valid parameters: "BTCUSDT", ["BTCUSDT", "BNBETH"], "top5", "top20".
        :param bid_spread: Optional, default: 0.05. The lower spread (in percentage) from the mid price for the opening buy limit order.
        :param ask_spread: Optional, default: 0.05. The upper spread (in percentage) from the mid price for the opening sell limit order.
        :param tp_spread: Optional, default: 0.10. The percentage spread from the opening price for the take profit order.
                :param base_asset: ...
        """
        self.client = client
        self.symbols = get_symbols(symbols, base_asset)
        self.base_asset = base_asset
        self.bid_spread = bid_spread
        self.ask_spread = ask_spread
        self.tp_spread = tp_spread

    def run(self):
        for symbol in self.symbols:
            thread = Thread(target=self.thread_fn, args=(symbol,))
            thread.start()

    def thread_fn(self, symbol):
        a = self.client.futures_get_open_orders(symbol=symbol)
        print(a)

'''


class PumpAndDump:
    def __init__(self, account: str, base_asset: Union[None, str], quote_asset: str, amount: float, is_amount_usd: bool,
                 entry_strategy: str, exit_strategy: str, profit: float, stop_loss: float = 0.0,
                 base_asset_input_mode: str = 'param', trailing_spread: float = 0.0, usd_asset='USDT',
                 test: bool = False, cred_fp: str = 'cred.json'):
        """
        :param account: The account to use for the strategy.
        :param base_asset: The base asset symbol.
        :param quote_asset: The quote asset symbol.
        :param amount: The amount to invest in the strategy. The amount is expressed in USD or in quote asset,
            depending on the parameter ``is_amount_usd>``. It is never expressed in base asset.
        :param is_amount_usd: If True, <amount> is expressed in USD. Otherwise, it is expressed in quote asset.
        :param entry_strategy: Can be "fixed", or "span".
        :param exit_strategy: Can be "fixed", "trailing".
        :param profit: The desired profit (in %).
        :param stop_loss: The spread from the current price to which close the order (in %).
        :param base_asset_input_mode: The following values are allowed.
            "param" (default): the strategy will read the base asset from the parameter <base_asset>;
            "telegram": the strategy will try to read the base asset symbol from the Telegram channel whose name is
                <channel_name>;
            "input": the strategy will ask the user to input the base asset symbol.
        :param trailing_spread: The spread for the trailing stop loss (in %).
            Used only if <exit_strategy> is "trailing".
        :param usd_asset: The stable asset. Must be one of ['USDT', 'USDC', 'BUSD', 'TUSD', 'USDP'].
        :param test: If True, all the orders are simulated and will never executed. Otherwise, the strategy will operate
            in the real market.
        """
        self.account = account
        self.base_asset = base_asset
        self.quote_asset = quote_asset
        self.amount = amount
        self.is_amount_usd = is_amount_usd
        self.entry_strategy = entry_strategy
        self.exit_strategy = exit_strategy
        self.profit = profit
        self.stop_loss = stop_loss
        self.base_asset_input_mode = base_asset_input_mode
        self.trailing_spread = trailing_spread
        self.usd_asset = usd_asset
        # self.channel_name = channel_name
        # self.phone_number = phone_number
        self.test = test

        assert account in ['binance', 'binance_sub', 'kucoin'], 'Account not recognized.'
        assert entry_strategy in ['fixed', 'span'], 'Entry strategy not recognized.'
        assert exit_strategy in ['fixed', 'trailing'], 'Exit strategy not recognized.'
        assert profit > 0, 'Profit must be positive.'
        assert 0 <= stop_loss <= 100, 'Stop loss must be in [0, 100] range.'
        assert base_asset_input_mode in ['param', 'telegram', 'input'], 'Base asset input mode not recognized.'
        assert trailing_spread >= 0, 'Trailing spread must be positive.'
        assert base_asset_input_mode != 'param' or (type(base_asset) == str), \
            "Base asset input mode is 'param', but base asset is not recognized."
        assert base_asset_input_mode == 'param' or entry_strategy == 'fixed', \
            "Entry strategy must be 'fixed' when the base asset is unknown."
        assert usd_asset in ['USDT', 'USDC', 'BUSD', 'TUSD', 'USDP'], 'Stablecoin not recognized.'

        self.client = get_client(account, cred_fp)

    def start(self):
        self.symbol = self.get_symbol()
        self.symbol_info = self.get_symbol_info()
        if not self.quote_asset in ['USDT', 'USDC', 'BUSD', 'TUSD', 'USDP'] and self.is_amount_usd:
            self.usd_info = self.get_usd_info()

        if self.account == 'binance' or self.account == 'binance_sub':
            buy_quote_quantity = self.get_buy_quote_quantity()
            if self.base_asset_input_mode == 'input':
                # BUY
                buy_params = {
                    'symbol': self.symbol,
                    'side': binance.enums.SIDE_BUY,
                    'type': binance.enums.ORDER_TYPE_MARKET,
                    'quoteOrderQty': buy_quote_quantity
                }
                if self.test:
                    buy_order = self.client.create_test_order(**buy_params)
                    avg_buy_price = 0
                else:
                    buy_order = self.client.create_order(**buy_params)
                    avg_buy_price = sum(float(fill['price']) for fill in buy_order['fills']) / len(buy_order['fills'])
                log_order(buy_order, buy_params, avg_buy_price, self.base_asset, self.quote_asset, self.test)
                # SELL
                if not self.test:
                    sell_price = avg_buy_price * (1 + self.profit / 100)
                    sell_params = {
                        'symbol': self.symbol,
                        'side': binance.enums.SIDE_SELL,
                        'type': binance.enums.ORDER_TYPE_LIMIT,
                        'timeInForce': binance.enums.TIME_IN_FORCE_GTC,
                        'quantity': self.format_base_quantity(buy_order['executedQty']),
                        'price': self.format_price(sell_price)
                    }
                    sell_order = self.client.create_order(**sell_params)
                    log_order(sell_order, sell_params, sell_price, self.base_asset, self.quote_asset, self.test)

        elif self.account == 'kucoin':
            raise Exception('Not implemented yet.')

        else:
            raise Exception('account not found.')

    def format_base_quantity(self, qty: Union[float, str]) -> str:
        """
        Format the base asset quantity (returned as a string) for the strategy symbol from a given amount.
        """
        precision = self.symbol_info['baseAssetPrecision']
        return f'{float(qty):.{precision}f}'

    def format_price(self, price: Union[float, str]) -> str:
        """
        Format the price (returned as a string) for the strategy symbol from a given amount.
        """
        precision = self.symbol_info['baseAssetPrecision']
        price_filter = None
        for filter in self.symbol_info['filters']:
            if filter['filterType'] == 'PRICE_FILTER':
                price_filter = filter
                break
        if price_filter:
            print(price_filter)
            tick_size = float(price_filter['tickSize'])
            return f'{(round(float(price) / tick_size) * tick_size):.{precision}f}'
        else:
            return f'{float(price):.{precision}f}'

    def get_buy_quote_quantity(self) -> str:
        """
        Get the quote asset quantity (returned as a string) for the strategy symbol from a given amount. Uses the stable
        asset price for the conversion if necessary. Use Binance quotes even if the strategy uses a different exchange.
        """
        if self.quote_asset in ['USDT', 'USDC', 'BUSD', 'TUSD', 'USDP'] or not self.is_amount_usd:
            precision = self.symbol_info['quoteAssetPrecision']
            return f'{self.amount:.{precision}f}'
        else:
            print(f'Getting {self.quote_asset + self.usd_asset} last price...')
            last_price = float(self.client.get_ticker(symbol=self.quote_asset + self.usd_asset)['lastPrice'])
            precision = self.usd_info['quoteAssetPrecision']
            quote_quantity = self.amount / last_price
            return f'{quote_quantity:.{precision}f}'

    def get_symbol(self) -> str:
        if self.base_asset_input_mode == 'telegram':
            raise Exception('Not implemented yet.')
            # Start a client for sniffing the base asset symbol
            # client = get_telegram_client()

            # @client.on(telethon.events.NewMessage(chats=self.channel_name))
            # async def my_event_handler(event):
            #    print(event.raw_text)

            # client.start(phone=self.phone_number)
            # client.run_until_disconnected()
            # base_asset = None
        elif self.base_asset_input_mode == 'input':
            if self.quote_asset:
                self.base_asset = input("Coin is: ").strip().upper()
            else:
                raise Exception('Quote asset is not given.')

        if self.account == 'binance' or self.account == 'binance_sub':
            return (self.base_asset + self.quote_asset).upper()
        elif self.account == 'kucoin':
            raise Exception('Not implemented yet.')
        else:
            raise Exception('account not found.')

    def get_symbol_info(self) -> Dict:
        print(f'Getting {self.symbol} information...')
        info = self.client.get_symbol_info(symbol=self.symbol)
        if info:
            return info
        else:
            raise Exception(f'Symbol {self.symbol} not found on Binance.')

    def get_usd_info(self) -> Dict:
        print(f'Getting {self.quote_asset + self.usd_asset} information...')
        info = self.client.get_symbol_info(symbol=self.quote_asset + self.usd_asset)
        if info:
            return info
        else:
            raise Exception(f'Symbol {self.symbol} not found on Binance.')
