import datetime as dt
import math

import numpy as np
import telethon
import time
from threading import Thread
from typing import Optional, Union, Any

from threaded import ThreadedAvellanedaStoikov
from utils import *

import binance
import binance.enums

'''
class AvellanedaStoikov:
    def __init__(self, key: str, secret: str, symbols: Union[list, str], risk_factor: float,
                 session_end: int = 23, session_length: int = 14, base_asset: str = 'USDT'):
        """
        :param key: The API key.
        :param secret: The API secret.
        :param symbols: A single symbol name or a list of symbol names to trade. Other than strings containing a symbol
            name, the following special
            strings are allowed:
            - "topX", where X is an integer. In this case, the X most capitalized cryptocurrencies will be selected,
                paired with *base_asset*.
            Case insensitive.
            Examples of valid parameters: "BTCUSDT", ["BTCUSDT", "BNBETH"], "top5", "top20".
        :param risk_factor: Optional, default: 0.1. A risk parameter that ranges from 0.0 to 1.0 (excluded).
        :param session_end: The ending hour of the daily session.
        :param session_length: The length of the daily session in hours.
        :param base_asset: ...
        """
        assert 0.0 < session_length < 24.0, 'Session length out of range'
        assert 0.0 < risk_factor < 1.0, 'Risk factor out of range'

        self.key = key
        self.secret = secret
        self.client = Client(key, secret)
        self.symbols = get_symbols(symbols, base_asset)
        self.base_asset = base_asset
        self.session_end = session_end
        self.session_length = session_length
        self.risk_factor = risk_factor
        self.twm = ThreadedWebsocketManager(self.key, self.secret)

    def start(self):
        self.twm.start()
        for symbol in self.symbols:
            ThreadedAvellanedaStoikov(caller=self, symbol=symbol).start()
        self.twm.join()

    def is_online(self):
        return self.client.ping() == {}

    def get_server_time(self):
        return dt.datetime.fromtimestamp(self.client.get_server_time()['serverTime'] / 1000)
'''

'''
class PerpetualMarketMaking:
    def __init__(self, client: Client, symbols: Union[list, str],
                 bid_spread: Optional[float] = 0.05, ask_spread: Optional[float] = 0.05,
                 tp_spread: Optional[float] = 0.1,
                 base_asset: str = 'USDT'):
        """
        :param client: The API client to use for the strategy.
        :param symbols: A single symbol name or a list of symbol names to trade. Other than strings containing a symbol name, the
            following special
            strings are allowed:
            - "topX", where X is an integer. In this case, the X most capitalized cryptocurrencies will be selected,
                paired with *base_asset*.
            Case insensitive.
            Examples of valid parameters: "BTCUSDT", ["BTCUSDT", "BNBETH"], "top5", "top20".
        :param bid_spread: Optional, default: 0.05. The lower spread (in percentage) from the mid price for the opening buy limit order.
        :param ask_spread: Optional, default: 0.05. The upper spread (in percentage) from the mid price for the opening sell limit order.
        :param tp_spread: Optional, default: 0.10. The percentage spread from the opening price for the take profit order.
                :param base_asset: ...
        """
        self.client = client
        self.symbols = get_symbols(symbols, base_asset)
        self.base_asset = base_asset
        self.bid_spread = bid_spread
        self.ask_spread = ask_spread
        self.tp_spread = tp_spread

    def run(self):
        for symbol in self.symbols:
            thread = Thread(target=self.thread_fn, args=(symbol,))
            thread.start()

    def thread_fn(self, symbol):
        a = self.client.futures_get_open_orders(symbol=symbol)
        print(a)

'''


class PumpAndDump:
    def __init__(self, account: str, base_asset: Optional[str], quote_asset: str, amount: float, is_amount_usd: bool,
                 entry_strategy: str, exit_strategy: str, profit: float, stop_loss: float = 0.0,
                 base_asset_input_mode: str = 'param', trailing_spread: float = 0.0, usd_asset='USDT',
                 # channel_name: str = '', phone_number: str = '',
                 cred_fp: str = 'cred.json'):
        """
        :param account: (Required) The account used by the strategy. The account must be registered in the credential
            JSON file pointed by <i>cred_fp</i>.
        :type account: str
        :param base_asset: (Optional) The base asset symbol. If it's not given, the strategy asks the user for it at
            runtime. However, <b>note</b> that if <i>base_asset_input_mode</i> == "param", this parameter is required.
        :type base_asset: str
        :param quote_asset: (Required) The quote asset symbol.
        :type quote_asset: str
        :param amount: (Required) The amount of money invested by the strategy. <b>Note:</b> This amount is expressed in
            USD or in quote asset, depending on the parameter <i>is_amount_usd</i>. It is never expressed in base asset.
        :type amount: float
        :param is_amount_usd: (Required) If True, <i>amount</i> is expressed in USD, otherwise in quote asset.
        :type is_amount_usd: bool
        :param entry_strategy: (Required) Can be "fixed", or "span".
        :type entry_strategy: str
        :param exit_strategy: (Required) Can be "fixed", "trailing".
        :type exit_strategy: str
        :param profit: (Required) The desired profit, in %.
        :type profit: float
        :param stop_loss: (Optional) The stop loss from the entry price, in %.
        :type stop_loss: float
        :param base_asset_input_mode (Optional): The following values are allowed.
            "param" (default): the strategy will read the base asset from the parameter <i>base_asset</i>;
            "telegram": the strategy will try to read the base asset symbol from the Telegram channel whose name is
            <i>channel_name</i>;
            "input": the strategy will ask the user to input the base asset symbol.
        :type base_asset_input_mode: str
        :param trailing_spread (Optional): The spread for the trailing stop loss, in %.
            Used only if <i>exit_strategy</i> == "trailing".
        :type trailing_spread: str
        :param usd_asset: The stable asset. Allowed values are "USDT", "USDC", "BUSD", "TUSD", or "USDP".
        :type usd_asset: str
        :param usd_asset: The stable asset. Allowed values are "USDT", "USDC", "BUSD", "TUSD", or "USDP".
        :type usd_asset: str
        """
        self.account = account
        self.base_asset = base_asset
        self.quote_asset = quote_asset
        self.amount = amount
        self.is_amount_usd = is_amount_usd
        self.entry_strategy = entry_strategy
        self.exit_strategy = exit_strategy
        self.profit = profit
        self.stop_loss = stop_loss
        self.base_asset_input_mode = base_asset_input_mode
        self.trailing_spread = trailing_spread
        self.usd_asset = usd_asset
        # self.channel_name = channel_name
        # self.phone_number = phone_number

        if not (amount > 0):
            raise ValueError('Amount must be positive')
        if entry_strategy not in ['fixed', 'span']:
            raise ValueError('Entry strategy not recognized')
        if exit_strategy not in ['fixed', 'trailing']:
            raise ValueError('Exit strategy not recognized')
        if not (profit > 0):
            raise ValueError('Profit must be positive')
        if not (0 <= stop_loss <= 100):
            raise ValueError('Stop loss must be in [0, 100] range')
        if base_asset_input_mode not in ['param', 'telegram', 'input']:
            raise ValueError('Base asset input mode not recognized')
        if not (trailing_spread >= 0):
            raise ValueError('Trailing spread must be zero or positive')
        if base_asset_input_mode == 'param' and (type(base_asset) != str):
            raise ValueError("Base asset input mode is 'param', but base asset is not recognized")
        if base_asset_input_mode != 'param' and entry_strategy != 'fixed':
            raise ValueError("Entry strategy must be 'fixed' when the base asset is given at runtime")
        if usd_asset not in STABLE_ASSETS:
            raise ValueError('Stablecoin not recognized')

        self.client = get_client(account, cred_fp)

    def start(self):
        """
        Start the strategy.
        """
        self.symbol = self.get_symbol()
        self.symbol_info = self.get_symbol_info()
        if not self.quote_asset in STABLE_ASSETS and self.is_amount_usd:
            self.usd_info = self.get_usd_info()

        if self.account in ['binance', 'binance_sub', 'binance_test']:
            buy_quote_quantity = self.format_quote_quantity(self.get_quote_quantity())
            # BUY
            buy_params = {
                'symbol': self.symbol,
                'side': binance.enums.SIDE_BUY,
                'type': binance.enums.ORDER_TYPE_MARKET,
                'quoteOrderQty': buy_quote_quantity
            }
            buy_order = self.client.create_order(**buy_params)
            avg_buy_price = self.get_avg_price(buy_order)
            log_order(buy_order, buy_params, avg_buy_price, self.base_asset, self.quote_asset)
            # SELL
            sell_price = avg_buy_price * (1 + self.profit / 100)
            sell_params = {
                'symbol': self.symbol,
                'side': binance.enums.SIDE_SELL,
                'type': binance.enums.ORDER_TYPE_LIMIT,
                'timeInForce': binance.enums.TIME_IN_FORCE_GTC,
                'quantity': self.format_base_quantity(buy_order['executedQty']),
                'price': self.format_price(sell_price)
            }
            sell_order = self.client.create_order(**sell_params)
            log_order(sell_order, sell_params, sell_price, self.base_asset, self.quote_asset)

        elif self.account == 'kucoin':
            raise NotImplementedError

    def format_base_quantity(self, qty: Union[float, str]) -> str:
        """
        Format a quantity according to the base asset decimal precision.
        """
        precision = self.symbol_info['baseAssetPrecision']
        return f'{float(qty):.{precision}f}'

    def format_quote_quantity(self, qty: Union[float, str]) -> str:
        """
        Format a quantity according to the quote asset decimal precision.
        """
        if self.quote_asset in STABLE_ASSETS or not self.is_amount_usd:
            precision = self.symbol_info['quoteAssetPrecision']
            return f'{float(qty):.{precision}f}'
        else:
            log(f'Getting {self.quote_asset + self.usd_asset} last price...')
            last_price = float(self.client.get_ticker(symbol=self.quote_asset + self.usd_asset)['lastPrice'])
            precision = self.usd_info['quoteAssetPrecision']
            quote_quantity = float(qty) / last_price
            return f'{quote_quantity:.{precision}f}'

    def format_price(self, price: Union[float, str]) -> str:
        """
        Format a price according to the quote asset decimal precision.
        """
        precision = self.symbol_info['quoteAssetPrecision']
        price_filter = None
        for filter in self.symbol_info['filters']:
            if filter['filterType'] == 'PRICE_FILTER':
                price_filter = filter
                break
        if price_filter:
            tick_size = float(price_filter['tickSize'])
            return f'{(round(float(price) / tick_size) * tick_size):.{precision}f}'
        else:
            return f'{float(price):.{precision}f}'

    def get_avg_price(self, order) -> float:
        """
        Get the average price of an order.
        """
        prices = [float(fill['price']) for fill in order['fills']]
        quantities = [float(fill['qty']) for fill in order['fills']]
        return np.average(prices, weights=quantities)

    def get_quote_quantity(self) -> float:
        if self.quote_asset in STABLE_ASSETS or not self.is_amount_usd:
            return self.amount
        else:
            log(f'Getting {self.quote_asset + self.usd_asset} last price...')
            last_price = float(self.client.get_ticker(symbol=self.quote_asset + self.usd_asset)['lastPrice'])
            return self.amount / last_price

    def get_symbol(self) -> str:
        if self.base_asset_input_mode == 'telegram':
            raise NotImplementedError
            # Start a client for sniffing the base asset symbol
            # client = get_telegram_client()

            # @client.on(telethon.events.NewMessage(chats=self.channel_name))
            # async def my_event_handler(event):
            #    print(event.raw_text)

            # client.start(phone=self.phone_number)
            # client.run_until_disconnected()
            # base_asset = None
        elif self.base_asset_input_mode == 'input':
            if self.quote_asset:
                self.base_asset = input("Base asset is: ").strip().upper()
            else:
                raise Exception('Quote asset is not given.')

        if self.account in ['binance', 'binance_sub', 'binance_test']:
            return (self.base_asset + self.quote_asset).upper()
        elif self.account == 'kucoin':
            raise NotImplementedError

    def get_symbol_info(self) -> dict[str, Any]:
        log(f'Getting {self.symbol} information...')
        info = self.client.get_symbol_info(symbol=self.symbol)
        if info:
            return info
        else:
            raise ValueError(f'Symbol {self.symbol} not found on Binance.')

    def get_usd_info(self) -> dict[str, Any]:
        log(f'Getting {self.quote_asset + self.usd_asset} information...')
        info = self.client.get_symbol_info(symbol=self.quote_asset + self.usd_asset)
        if info:
            return info
        else:
            raise ValueError(f'Symbol {self.symbol} not found on Binance.')
